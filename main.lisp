(import 'charset:utf-8 'keyword)

(defvar Lst '())
(defvar Lst2 '())
(defvar AndOrNot '())
(defvar Case '("No case"))
(defvar CaseName '())

(defun ClearLst()
    (pop Lst)
    (if (null Lst)()
    (clearLst))
)

(defun FullComLst (str)	
    (if (string/= "" str)(push (substring str 0 (search " " str)) Lst ))
    (if (search " " str)( 
        FullComLst(substring str (+ (search " " str) 1) (length str))
    )(nreverse Lst))
)

(defun ColumnsOrigin(lis)
(clearLst)
(Columns lis)
)

(defun Columns (lis)	
    (cond 
        ((string= (car lis) "select")(columns(cdr lis)))
        ((null lis)(ParseColumn (nreverse Lst)))
		((string= (car lis) "case")(ParseColumn (nreverse Lst)))
        ((string= (car lis) "from")(ParseColumn (nreverse Lst)))
        (t (columns1 lis))
        )
)

(defun Columns1 (lis)
    (push (car lis) Lst)
    (columns (cdr lis))    
)

(defun ParseColumn (lis)
    (cond 
        ((null lis)(nreverse lst2))
        (t (ParseColumn1 lis))
    )
)

(defun ParseColumn2 (str)
    (if (string/= "" str)(push (substring str 0 (search "," str)) lst2 ))        
    (if (search "," str)( 
        ParseColumn2(substring str (+ (search "," str) 1) (length str))
    )lst2)
)

(defun ParseColumn1 (lis)
    (ParseColumn2 (car lis))
    (ParseColumn (cdr lis))
)

(defun GetNameFile(lis)
    (cond
    	((string= (car lis) "from")(cadr lis))
    	(t (GetNameFile (cdr lis)))
    )
)

(defun WhereAtr (lis)
	(ClearLst)

    (cond
        ((null lis)'("No where"))
		((string= (car lis) "case")(CaseSkip (cdr lis)))
        ((string= (car lis) "where")(nreverse (WhereAtr1 (cdr lis))))
        (t (whereatr (cdr lis)))
    )
)

(defun CaseSkip(lis)
	(cond 
		((string= (car lis) "end")(WhereAtr (cdr lis)))
		(t(CaseSkip (cdr lis)))
	)
)

(defun WhereAtr1 (lis)
	(push (car lis) Lst)
	(if(or (string= (cadr lis) "and") (string= (cadr lis) "or") (string= (cadr lis) "not"))(push (cadr lis) AndOrNot)(nreverse AndOrNot))
	(if(or (string= (cadr lis) "and") (string= (cadr lis) "or") (string= (cadr lis) "not"))(WhereAtr1 (cddr lis))Lst)	
)

(defun CaseAtrF (lis)
	(ClearLst)
	(cond
		((null lis)'("No case"))		
		((string= (car lis) "case")(CaseAtr1 (cdr lis)))
		(t(CaseAtrF (cdr lis)))
	)
)

(defun CaseAtr1(lis &optional (useless '()))
	(setf Case '("Case"))
	(if (string= (car lis) "else")(push "else" Lst))
	(if (string= (car lis) "end")(push (caddr lis) CaseName))
	(cond 
		((null lis)(error "Case error"))
		((string= (car lis) "where")(CaseAtr1 (cdr lis) (push (cadr lis) Lst)))
		((string= (car lis) "then")(CaseAtr1 (cdr lis) (push (cadr lis) Lst)))
		((string= (car lis) "else")(CaseAtr1 (cdr lis) (push (cadr lis) Lst)))
		((string= (car lis) "end")(nreverse Lst))
		(t(CaseAtr1 (cdr lis)))
	)
)


(defun OrderByAtr(lis)
	(ClearLst)
    (cond
        ((null lis)'("No order"))
        ((string= (car lis) "order")(nreverse (OrderByAtr1 (cddr lis))))
        (t (OrderByAtr (cdr lis)))
    )
)

(defun OrderByAtr1(lis)

	(if (and (search "," (car lis)) (string/= (car lis) ","))
		(if (string/= (substring (car lis) 0 (search "," (car lis))) "")
			(push (substring (car lis) 0 (search "," (car lis))) Lst)
			(push (substring (car lis) (+ (search "," (car lis)) 1) (length (car lis))) Lst)
		)(push (car lis) Lst)
	)	
	(cond 
		((search  "desc" (cadr lis))(push "desc" Lst))
		(t(push "asc" Lst))		
	)
	(cond

		((search "," (car lis))(OrderByAtr1 (cdr lis)))
		((search "," (cadr lis))(OrderByAtr1 (cdr lis)))
		((string= (cadr lis) ",")(OrderByAtr1 (cddr lis)))
		((string= (caddr lis) ",")(OrderByAtr1 (cdddr lis)))
		(t Lst)
	)
)

(defun JoinTbAtr(lis)
	(ClearLst)
	(cond 
		((null lis)'("No join"))
		((or (string= "inner" (car lis)) (string= "full" (car lis)) (string= "left" (car lis)) (string= "right" (car lis)))(nreverse (JoinTbAtr1 lis)))
		(t(JoinTbAtr (cdr lis)))
	)
)

(defun JoinTbAtr1(lis &optional (useless '()))
	(cond 
		((or (string= "inner" (car lis)) (string= "full" (car lis)) (string= "left" (car lis)) (string= "right" (car lis)) (string= "outer" (car lis)))(JoinTbAtr1 (cdr lis) (push (car lis) Lst)))
		((string= (car lis) "join")(JoinTbAtr1 (cdr lis) (push (cadr lis) Lst)))
		((string= (car lis) "on")(JoinTbAtr2 (cdr lis)))
		(t(JoinTbAtr1 (cdr lis)))
	)
	Lst
)

(defun JoinTbAtr2(lis)
	(if (search "=" (car lis))
		(JoinTbAtr3 lis)
		(JoinTbAtr4 lis)
	)
)

(defun JoinTbAtr3(lis)
	(push (substring (car lis) 0 (search "=" (car lis))) Lst)
	(if (search "." (substring (car lis) (+ 1 (search "=" (car lis))) (length (car lis))))(push (substring (car lis) (+ 1 (search "=" (car lis))) (length (car lis))) Lst)
		(push (cadr lis) Lst))
)

(defun JoinTbAtr4(lis)
	(push (car lis) Lst)
	(if (string= (cadr lis) "=")(push (caddr lis) Lst)
		(push (substring (cadr lis) (+ (search "=" (cadr lis)) 1) (length (cadr lis))) Lst)
	)
)

(defun GroupByAtr(lis)
	(clearLst)
	(cond
		((null lis)'("No group"))
		((string= (car lis) "group")(GroupByAtr1 (cddr lis)))
		(t(GroupByAtr (cdr lis)))
	)
)

(defun GroupByAtr1 (lis)
	(push (car lis) Lst)
	(if (string= (cadr lis) "having")(push (caddr lis) Lst))
	(nreverse Lst)
)

(defun ReadCommand (str)
	(setq Index (search " " str))
	(cond
		((string= (substring str 0 Index) "select") "select")
		(t (print "Неизвестная команда"))))

(defun ParseTable (Data)
	(cond
		((EndOfSting Name "tsv") (TableSeparator Data (string #\tab)))
		((EndOfSting Name "csv") (TableSeparator Data ","))
		(t (print "Ошибка открытия файла"))))

(defun FixedStrLst(lis)
	(clearLst)
	(FixedStrLst1 lis)
)

(defun FixedStrLst1(lis  &optional (useless '()))
	(if (not (null lis))
		(if(search "\"" (car lis))
			(FixedStrLst2 (cdr lis) (substring (car lis) (+ (search "\"" (car lis))1) (length (car lis))))
			(FixedStrLst1 (cdr lis) (push (car lis) Lst))		
		)
		(nreverse Lst)
	)
)

(defun FixedStrLst2 (lis str &optional (useless '()) )
	(if (search "\"" str)
		(FixedStrLst1 (cdr lis) (push (substring str 0 (search "\"" str)) Lst))
		(if (search "\"" (car lis))
			(FixedStrLst1 (cdr lis) (push (concatenate 'string str " " (substring (car lis) 0 (search "\"" (car lis))) ) Lst))
			(FixedStrLst2 (cdr lis) (concatenate 'string str " " (car lis) )))
	)
)

(defun TableSeparator (Data separator)
	(mapcar #'(lambda (row) (Split1 row separator)) Data))

(defun PrintTable (Table)
	(mapcar
		#'(lambda (row)
			(mapcar
				#'(lambda (val)
					(format t "| ~A |" (if (> (length val) 15)(substring val 0 15)val)))
				row)
			(format t "~C" #\linefeed))
		Table)) 


	(defun ReadFile (Input &optional (Data '()))
	(setq line (read-line Input nil))
	(cond
		(line (ReadFile Input (append Data (list line))))
		(t Data))) 

(defun ExecuteProg (command str)
	(cond
		((string= command "select")
			(setq
				CommandStrLst (FullComLst str)
				CommandStrLst1(FixedStrLst CommandStrLst)
				SelectAtr(ColumnsOrigin CommandStrLst1)
				Name (GetNameFile CommandStrLst1)
				CaseAt (CaseAtrF CommandStrLst1)
				WhAtr(WhereAtr CommandStrLst1)
				OrderAtr(OrderByAtr  CommandStrLst1)
				JoinAtr(JoinTbAtr CommandStrLst1)
				GroupAtr(GroupByAtr CommandStrLst1)
				Data (ReadFile (open Name :external-format :utf-8))
				Table (ParseTable Data)
				TableJoin(TableJoinParser Table JoinAtr Name)
				TableWhere(TableWhereParser TableJoin WhAtr)
				TableOrder(TableOrderParser TableWhere OrderAtr GroupAtr)
				TableColumn (TableColumnParser TableOrder SelectAtr GroupAtr CaseAt)
				)	
			(PrintTable TableColumn)			
			)
		)) 

(defun EndOfSting (str1 str2)
	(setq match (mismatch str2 str1 :from-end t))
	(or (not match) (= 0 match)))


(defun Split1 (string &optional (separator "  ") (r nil))
  (let ((n (position separator string
		     :from-end t
		     :test #'(lambda (x y)
			       (find y x :test #'string=)))))
				   (cond
						((string= (car r) "")(setf r '("null")))
						((string= (car r) " ")(setf r '("null")))
				   )				   
    (if n
	(Split1 (subseq string 0 n) separator (cons (subseq string (1+ n)) r))
      (cons string r)))) 

(defun TableColumnParser(table atr GroupAtr CaseAtr)
	(clearLst)
	(if (string/= "No group" (car GroupAtr))(Group table atr GroupAtr CaseAtr)
	(if (SearchFunc atr)
		(FunExecute table atr (car table))
		(if (string= (car Case) "No case")
			(if(position "*" atr :test #'equal)table(TableColumnParser1 table atr))
			(if(position "*" atr :test #'equal)(AppendTableF table (TableWhereParserCase table CaseAtr) table)(AppendTableF (TableColumnParser1 table atr) (TableWhereParserCase table CaseAtr) (TableColumnParser1 table atr)))
			)))
)

(defun AppendTableF(FirstTable SecondTable FullTable &optional (EndTable '()))
	(if (not (null FirstTable))
		(AppendTableF1 (cdr FirstTable) (cdr SecondTable) FullTable EndTable)
		(AppendTableF2 (append (car FullTable) CaseName) EndTable))
)

(defun AppendTableF2(ColumnName EndTable)
	(nreverse EndTable)
	(push ColumnName EndTable)
)

(defun AppendTableF1(FirstTable SecondTable FullTable &optional (EndTable '()))
	(if (null (cdr FirstTable))
		(AppendTableF FirstTable SecondTable FullTable (push (append (car FirstTable) (car SecondTable)) EndTable))
		(AppendTableF FirstTable SecondTable FullTable (push (append (car FirstTable) (car SecondTable)) EndTable)))
)

(defun Group(table atr GroupAtr CaseAtr)
	(if (SearchFunc atr)(Group1 table atr GroupAtr)
		(if (and (< (list-length atr) 2) (string= (car atr) (car GroupAtr)))(TableColumnParser table (push "distinct" atr) '("No group") CaseAtr)(error "Group By error"))
	)
)

(defun Group1(table atr GroupAtr)
	(setq col (loop for x in atr collect (if(not (search "(" x ))x)))
	(setf col (remove NIL col))
	(setq func (loop for x in atr collect (if(search "(" x )x)))
	(setf func (remove NIL func))
	(setq ind (IndexColumns (car table) (list (car GroupAtr))))
	(if (and (< (list-length col) 2) (string= (car col) (car GroupAtr)))(Group2 table (cdr table) col func ind GroupAtr)(error "Group By error(2)"))
)

(defun Group2(FullTable MainTable col func GroupInd GroupAtr &optional (HelperTable '()) (EndTable '()))
	(if (not (null MainTable))
		(if (string= (nth (car GroupInd) (car MainTable)) (nth (car GroupInd) (cadr MainTable)))
			(Group2 FullTable (cdr MainTable) col func GroupInd GroupAtr (push (car MainTable) HelperTable) EndTable)
			(if(not (null (cadr GroupAtr)))
				(Group3 FullTable (cdr MainTable) col func GroupInd GroupAtr (push (car MainTable) HelperTable) EndTable)
				(Group4 FullTable (cdr MainTable) col func GroupInd GroupAtr (push (car MainTable) HelperTable) EndTable))	
		)
		(HelpGroupFunc FullTable MainTable col func GroupInd GroupAtr HelperTable EndTable )
	)
)

(defun Group3(FullTable MainTable column func GroupInd GroupAtr HelperTable EndTable)
	(setq Sign (WhSign (cadr GroupAtr)))
	(setq Col (substring (cadr GroupAtr) 0 (search Sign (cadr GroupAtr))))
	(setq Val (WhVal (list (cadr GroupAtr)) (list Sign)))
	(clearLst)
	(if (search "(" Col)
		(if(comparison (cadr (FunExecute HelperTable (list col) (car FullTable))) 0 Sign (car Val))
			(Group4 FullTable MainTable column func GroupInd GroupAtr HelperTable EndTable)
			(Group2 FullTable MainTable column func GroupInd GroupAtr '() EndTable))
		(if(comparison Col 0 Sign (car Val))
			(Group4 FullTable MainTable column func GroupInd GroupAtr HelperTable EndTable)
			(Group2 FullTable MainTable column func GroupInd GroupAtr '() EndTable))		
	)	
)

(defun Group4(FullTable MainTable column func GroupInd GroupAtr HelperTable EndTable)
	(setq ver (loop for x in func collect (caadr (FunExecute HelperTable (list x) (car FullTable)))))
	(clearLst)
	(setq ind (IndexColumns (car FullTable) column))
	(clearLst)
	(if (not (null column))(push (nth (car ind) (car HelperTable)) ver))
	(Group2 FullTable MainTable column func GroupInd GroupAtr '() (push ver EndTable))
)

(defun HelpGroupFunc(FullTable MainTable column func GroupInd GroupAtr HelperTable EndTable)
	(setq endcol (loop for x in func collect(caar (FunExecute (cdr FullTable) (list x) (car FullTable)))))
	(clearLst)
	(setq ind (IndexColumns (car FullTable) column))
	(if (not (null column))(push (nth (car ind) (car FullTable)) endcol))
	(nreverse EndTable)
	(push endcol EndTable)
)

(defun SearchFunc(atr)
	(if (string= (car atr) "distinct")(SearchFunc (cdr atr)))
	(if (not (null atr))(if (search "(" (car atr))(search "(" (car atr))(SearchFunc (cdr atr)))NIL)
)

(defun FunExecute(table atr ColName)
	(if (string= (car atr) "distinct")(SearchFunc (cdr atr)))
	(if (not (null atr))
		(if (search "(" (car atr))
			(cond 
				((string= (substring (car atr) 0 (search "(" (car atr))) "COUNT")(CountFunc table (substring (car atr) (+ (search "(" (car atr)) 1)  (search ")" (car atr))) ColName))
				((string= (substring (car atr) 0 (search "(" (car atr))) "Min")(MinFunc table (list (substring (car atr) (+ (search "(" (car atr)) 1)  (search ")" (car atr)))) ColName))
				((string= (substring (car atr) 0 (search "(" (car atr))) "Avg")(AvgFunc table (substring (car atr) (+ (search "(" (car atr)) 1)  (search ")" (car atr))) ColName))
			)
		)
	)
)

(defun AvgFunc (table atr ColName)
	(setq index (IndexColumns ColName (list atr)))
	(setq ATable '(("Avg")))
	(setq AvgVal (AvgFunc1 (cdr table) (car index)))
	(append ATable (list (list (write-to-string AvgVal))))
)

(defun AvgFunc1(table index  &optional (Avg 0) (CountVal 0) )
	(if (null table) (floor Avg CountVal)
		(if (or (string= (nth index (car table)) "null") (null (nth index (car table))))
			(AvgFunc1 (cdr table) index Avg)
			(if (or (search "1" (nth index (car table))) (search "2" (nth index (car table))) (search "3" (nth index (car table))) (search "4" (nth index (car table)) ) (search "5" (nth index (car table)) ) (search "6" (nth index (car table)) ) (search "7" (nth index (car table)) ) (search "8" (nth index (car table)) ) (search "9" (nth index (car table)) ) (search "0" (nth index (car table))))
				(AvgFunc1 (cdr table) index (+ Avg (parse-integer (nth index (car table)))) (+ CountVal 1))
				(error "Only numbers")
			)
		)
	)
)

(defun MinFunc (table atr ColName)
	(setq index (IndexColumns ColName atr))
	(setq ATable '(("Mnimum")))
	(setq MinVal (MinFunc2 (cdr table) (car index) (nth (car index) (cadr table))))
	(append ATable (list (list  MinVal)))
)


(defun MinFunc2 (table index Min)
	(if (or (null Min) (string= Min "null"))(MinFunc2 (cdr table) index (nth index (cadr table))))
	(if (not (null table))
		(cond
			((or (string= (nth index (car table)) "null") (null (nth index (car table)))) (MinFunc2 (cdr table) index Min) )
			((or (search "1" (nth index (car table))) (search "2" (nth index (car table))) (search "3" (nth index (car table))) (search "4" (nth index (car table)) ) (search "5" (nth index (car table)) ) (search "6" (nth index (car table)) ) (search "7" (nth index (car table)) ) (search "8" (nth index (car table)) ) (search "9" (nth index (car table)) ) (search "0" (nth index (car table))))
				(if (< (parse-integer (nth index (car table))) (parse-integer Min))(MinFunc2 (cdr table) index (nth index (car table)))(MinFunc2 (cdr table) index Min))
			)
			(t(if (string< (nth index (car table)) Min)(MinFunc2 (cdr table) index (nth index (car table)))(MinFunc2 (cdr table) index Min)))
		)
	)Min
)

(defun CountFunc(table atr ColName)
	(setq ATable '(("Count")))
	(setq CountVal (if (string= atr "*")
				(CountFunc1 (cdr table))
				(CountFunc1 (cdr table) (car (IndexColumns ColName (list atr))))
			))	
	(append ATable (list (list (write-to-string CountVal))))
)

(defun CountFunc1(table &optional (index nil) (counter 0))
	(if (null table)counter
		(if (null index)
			(CountFunc1 (cdr table) index (+ counter 1))
			(if (or (string= (nth index (car table)) "null") (null (nth index (car table))))
				(CountFunc1 (cdr table) index counter)
				(CountFunc1 (cdr table) index (+ counter 1))
			)
		)
	)
)

(defun TableColumnParser1(table atr)
	(setq index (IndexColumns (car table) atr))
	(setq lit (loop for n in table collect (loop for x in index 
		collect (nth x n))))
	(if(string= (car atr) "distinct")(Distinct lit)lit)
)

(defun Distinct(ls)
	(clearLst)
	(loop for x in ls do (if(position x Lst :test #'equal)()(push x Lst)))
	(nreverse Lst)
)

(defun IndexColumns(ls atr)
	(if(null (car atr))(nreverse Lst)(IndexColumns1 ls atr))
)

(defun IndexColumns1 (ls atr)	
	(if(string/= (car atr) "distinct")(if(position (car atr) ls :test #'equal)(push (position (car atr) ls :test #'equal) Lst)(error "Error column")))
	(IndexColumns ls (cdr atr))
)

(defun TableWhereParser (table atr)
	(if(string= (car atr) "No where")table(TableWhereParser1 table atr))
)

(defun TableWhereParserCase(table atr)
	(setq CaseCond(loop for x in atr collect(if(CaseSign x)x)))
	(setf CaseCond (remove Nil CaseCond))
	(setq CaseThen(loop for x in atr collect(if(not (CaseSign x))x)))
	(setf CaseThen (remove Nil CaseThen))
	(setq EndTable (loop for x in (cdr table) collect 
						(TableWhereParserCase1 x CaseCond CaseThen (car table) CaseThen)
						))
	(setq Sign (WhSign (car CaseCond)))
	(setq Col (substring (car CaseCond) 0 (search Sign (car CaseCond))))
	(setq Val (WhVal (list (car CaseCond)) (list Sign)))
	(setq ind (IndexColumns (car table) (list Col)))
	(setf EndTable(loop for x in EndTable collect (list (nth (car ind) x))))
	(push '(("useless")) EndTable)
)


(defun TableWhereParserCase1(tablecol CaseCond CaseThen tb CaseThenFull &optional (ind 0) (test 0) )
	(clearLst)
	(if(= test 0)
		(if (not (null CaseCond))
		(TableWhereParserCase2 tablecol (car CaseCond) (car CaseThen) CaseCond CaseThen tb CaseThenFull ind)tablecol)
		tablecol
	)
)


(defun TableWhereParserCase2(tablecol CaseCond CaseThen CaseCondFull CaseThenFull  tb CaseThenFull2 &optional (ind 0))
	(if (string/= CaseCond "else")
		(TableWhereParserCase4 tablecol CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2)
		(TableWhereParserCase5 tablecol CaseCond CaseThen CaseCondFull CaseThenFull2 tb CaseThenFull2 ind))
)

(defun TableWhereParserCase3(tablecol CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2 ind &optional (useless '()))
	(if (not (null tablecol))
		(if(= ind 0)(TableWhereParserCase3 (cdr tablecol) CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2 (- ind 1) (push CaseThen Lst))
			(TableWhereParserCase3 (cdr tablecol) CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2 (- ind 1) (push (car tablecol) Lst)))
		(TableWhereParserCase1 (nreverse Lst) (cdr CaseCondFull) (cdr CaseThenFull) tb CaseThenFull2 ind 1)
	)
)

(defun TableWhereParserCase4(tablecol CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2)
	(setq Sign (WhSign CaseCond))
	(setq Col (substring CaseCond 0 (search Sign CaseCond)))
	(setq Val (WhVal (list CaseCond) (list Sign)))
	(setq ind (IndexColumns tb (list Col)))
	(clearLst)
	(if (comparison tablecol (car ind) Sign (car Val))(TableWhereParserCase3 tablecol CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2 (car ind))
		(TableWhereParserCase1 tablecol (cdr CaseCondFull) (cdr CaseThenFull) tb CaseThenFull2 ind))
)

(defun TableWhereParserCase5(tablecol CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2 ind)
	(if (not (null CaseThenFull))
		(if (string/= (car CaseThenFull) (nth (car ind) tablecol))
				(TableWhereParserCase5 tablecol CaseCond CaseThen CaseCondFull (cdr CaseThenFull) tb CaseThenFull2 ind)
				(TableWhereParserCase1 tablecol (cdr CaseCondFull) (cdr CaseThenFull) tb CaseThenFull2 ind))
		(TableWhereParserCase3 tablecol CaseCond CaseThen CaseCondFull CaseThenFull tb CaseThenFull2 (car ind))
	)
)

(defun CaseSign(atr)
	(cond 
		((search "<=" atr)"<=")
		((search ">=" atr)">=")
		((search "<>" atr)"<>")
		((search "=" atr)"=")
		((search ">" atr)">")
		((search "<" atr)"<")
		((string= atr "else"))
	)
)

(defun TableWhereParser1 (table atr)
	(setq Sign (loop for x in atr collect(WhSign x)))
	(setq Col (loop for x in atr collect(substring x 0 (search (nth (position x atr :test #'equal) Sign) x))))
	(setq Val (WhVal atr Sign))
	(clearLst)
	(setq ind (IndexColumns (car table) Col))
	(clearLst)
	(push NIL AndOrNot)
	(setq TbWh (TableWhereParser2 (cdr table) ind Sign Val (cdr table) AndOrNot) )
	(push (car table) TbWh)
)

(defun TableWhereParser2 (table ind Sign val FullTable r)
	(if (null (car val))table(TableWhereParser3 table ind Sign val FullTable r))
)

(defun TableWhereParser3 (table ind Sign val FullTable r)
	(cond 
		((or (null (car r)) (string= (car r) "and") (string= (car r) "not"))(loop for x in table do(
				if(not (null (comparison x (car ind) (car Sign) (car val))))
				(push (comparison x (car ind) (car Sign) (car val)) Lst)
			)))
		((string= (car r) "or")(loop for x in FullTable do(
				if(not (null (comparison x (car ind) (car Sign) (car val))))
				(push (comparison x (car ind) (car Sign) (car val)) Lst)
			)))
	)	
	(nreverse Lst)
	(cond 
		((or (null (car r)) (string= (car r) "and"))(setq ls Lst))
		((string= (car r) "or")(setq ls (append table Lst)))
		((string= (car r) "not")(setq ls (DeleteLists table Lst)))
	)
	(clearLst)
	(TableWhereParser2 ls (cdr ind) (cdr Sign) (cdr val) FullTable (cdr r) )
)

(defun DeleteLists(firstList secondList)
	(if(not (null secondList))(DeleteLists (remove (car secondList) firstList) (cdr secondList))firstList)
)

(defun comparison (ls ind Sg Vl)	
	(if (or (search "1" Vl ) (search "2" Vl ) (search "3" Vl) (search "4" Vl ) (search "5" Vl ) (search "6" Vl ) (search "7" Vl ) (search "8" Vl ) (search "9" Vl ) (search "0" Vl ))
		(if(and (string/= (nth ind ls) "null") (not (null (nth ind ls))))
			(cond 
			((string= "=" Sg)(if(= (parse-integer Vl) (parse-integer (nth ind ls)))ls))
			((string= ">" Sg)(if(< (parse-integer Vl) (parse-integer (nth ind ls)))ls))
			((string= "<" Sg)(if(> (parse-integer Vl) (parse-integer (nth ind ls)))ls))
			((string= ">=" Sg)(if(or (< (parse-integer Vl) (parse-integer (nth ind ls))) (= (parse-integer Vl) (parse-integer (nth ind ls))))ls))
			((string= "<=" Sg)(if(or (> (parse-integer Vl) (parse-integer (nth ind ls))) (= (parse-integer Vl) (parse-integer (nth ind ls))))ls))
			((string= "<>" Sg)(if(not (= (parse-integer Vl) (parse-integer (nth ind ls))))ls)))
		)		
		(cond
			((string= "=" Sg)(if(string= Vl (nth ind ls))ls))
			((string= ">" Sg)(if(string< (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls))ls))
			((string= "<" Sg)(if(string> (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls))ls))
			((string= ">=" Sg)(if(or (string< (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls)) (= (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls)))ls))
			((string= "<=" Sg)(if(or (string> (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls)) (= (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls)))ls))
			((string= "<>" Sg)(if(not (string= (substring Vl (+ (search "\"" (nth ind ls)) 1) (search "\"" (nth ind ls) :from-end t)) (nth ind ls)))ls))
		)
	)
)

(defun WhVal(atr Sign)
	(loop for x in atr collect
	(if(and (string/= (nth (position x atr :test #'equal) Sign) "<=") (string/= (nth (position x atr :test #'equal) Sign) ">=") (string/= (nth (position x atr :test #'equal) Sign) "<>"))
	(substring x (+ (search (nth (position x atr :test #'equal) Sign) x) 1) (length x))
	(substring x (+ (search (nth (position x atr :test #'equal) Sign) x) 2) (length x))))
)


(defun WhSign(atr)
	(cond 
		((search "<=" atr)"<=")
		((search ">=" atr)">=")
		((search "<>" atr)"<>")
		((search "=" atr)"=")
		((search ">" atr)">")
		((search "<" atr)"<")
		(t(error "Error sign"))
	)
)

(defun TableOrderParser(table atr GroupAtr)
	(if (string/= "No group" (car GroupAtr))
		(if(string= (car atr) "No order")(setf atr (list (car GroupAtr)))(push (car GroupAtr) atr))
	)
	(if (string/= "No group" (car GroupAtr))
		(if(string= (car atr) "No order")(setf atr (list (car GroupAtr)))(push "asc" atr))
	)
	(if (string= (car atr) "No order")table(TableOrderParser1 table atr GroupAtr))
)

(defun TableOrderParser1(table atr GroupAtr)
	(setq col (loop for x in atr collect
		(if(and (string/= x "asc") (string/= x "desc"))x)))
	(setf col (remove nil col))
	(setq atrcol (loop for x in atr collect
		(if(or (string= x "asc") (string= x "desc"))x)))
	(setf atrcol (remove nil atrcol))
	(clearLst)
	(setq index (IndexColumns (car table) col))
	(clearLst)
	(setq stable (TableOrderParser2 (cdr table) index atrcol))
	(push (car table) stable)
)

(defun TableOrderParser2(table ind atr &optional (r '( )))
	(if (not (null ind))
		(TableOrderParser3 table ind atr r)
		table
	)
)

(defun TableOrderParser3(table ind atr &optional (r '( )))
	(setq SortTable (if (null r)(OrderSorting table (car ind) (car atr))(TableOrderParser4 table table (car ind) (car atr) (nreverse r) )))
	(TableOrderParser2 SortTable (cdr ind) (cdr atr) (push (car ind) r))
)

(defun TableOrderParser4(MainTable FullTable ind atr r &optional (HelperTable '()) (SortedTable '()))
	(if (not (null r))
		(if (not (null MainTable))
			(if (string= (nth (car r) (car MainTable)) (nth (car r) (cadr MainTable)))
				(TableOrderParser4 (cdr MainTable) FullTable ind atr r (push (car MainTable) HelperTable) SortedTable)
				(SortedTableFunction MainTable FullTable ind atr r (push (car MainTable) HelperTable) SortedTable)
			)
			(TableOrderParser4 SortedTable SortedTable ind atr (cdr r) )
		)
		FullTable
	)
)


(defun SortedTableFunction(MainTable FullTable ind atr r HelperTable SortedTable)
	(nreverse HelperTable)
	(setq STable (OrderSorting HelperTable ind atr))
	(TableOrderParser4 (cdr MainTable) FullTable ind atr r '() (append SortedTable STable)) 
)

(defun OrderSorting(table index atr)
	(if(string= atr "asc")
		(if (or (search "1" (nth index (car table))) (search "2" (nth index (car table))) (search "3" (nth index (car table))) (search "4" (nth index (car table)) ) (search "5" (nth index (car table)) ) (search "6" (nth index (car table)) ) (search "7" (nth index (car table)) ) (search "8" (nth index (car table)) ) (search "9" (nth index (car table)) ) (search "0" (nth index (car table))))
			(sort table #'< :key #'(lambda (x)(parse-integer (nth index x))))
			(sort table index #'string< :key #'(lambda (x)(nth index x))))
		(if (or (search "1" (nth index (car table))) (search "2" (nth index (car table))) (search "3" (nth index (car table))) (search "4" (nth index (car table)) ) (search "5" (nth index (car table)) ) (search "6" (nth index (car table)) ) (search "7" (nth index (car table)) ) (search "8" (nth index (car table)) ) (search "9" (nth index (car table)) ) (search "0" (nth index (car table))))
			(sort table #'> :key #'(lambda (x)(parse-integer (nth index x))))
			(sort table index #'string> :key #'(lambda (x)(nth index x))))
	)
)

(defun TableJoinParser(FirstTable atr FirstName)
	(if (string= (car atr) "No join")
			(BetterTable FirstTable (List-length (car FirstTable)))
			(TableJoinParser1 FirstTable atr FirstName)
	)
)

(defun TableJoinParser1(FirstTable atr FirstTableName)
	(if (string= (car atr) "full")
			(setq SecondTableName (caddr atr))
			(setq SecondTableName (cadr atr))
	)
	(if (string= (car atr) "full")
			(setq TbCol (cdddr atr))
			(setq TbCol (cddr atr))
	)
	(setq SecondTable (ParseTable (ReadFile (open SecondTableName :external-format :utf-8))))
	(clearLst)
	(TableJoinParser2 (BetterTable FirstTable (list-length (car FirstTable))) (BetterTable SecondTable (list-length (car SecondTable))) FirstTableName SecondTableName TbCol (car atr))
)

(defun TableJoinParser2(FirstTable SecondTable FirstTableName SecondTableName TbCol atr)
	(if (string= FirstTableName (substring (car TbCol) 0 (search "." (car TbCol) :from-end t)))
			(setq FirstIndex (IndexColumns (car FirstTable) (List (substring (car TbCol) (+ (search "." (car TbCol) :from-end t) 1) (length (car TbCol))))))
			(if (string= SecondTableName (substring (car TbCol) 0 (search "." (car TbCol) :from-end t)))
					(setq SecondIndex (IndexColumns (car SecondTable) (List (substring (car TbCol) (+ (search "." (car TbCol) :from-end t) 1) (length (car TbCol))))))
					(error "Error column join"))
	)
	(clearLst)
	(if (string= SecondTableName (substring (cadr TbCol) 0 (search "." (cadr TbCol) :from-end t)))
			(setq SecondIndex (IndexColumns (car SecondTable) (List (substring (cadr TbCol) (+ (search "." (cadr TbCol) :from-end t) 1) (length (cadr TbCol))))))
			(if (string= FirstTableName (substring (cadr TbCol) 0 (search "." (cadr TbCol) :from-end t)))
					(setq FirstIndex (IndexColumns (car FirstTable) (cadr (substring (cadr TbCol) (+ (search "." (cadr TbCol) :from-end t) 1) (length (cadr TbCol))))))
					(error "Error column join"))
	)
	(clearLst)
	(cond 
		((string= atr "inner")(setq EndTable (InnerJoin (cdr FirstTable) (cdr SecondTable) (car FirstIndex) (car SecondIndex))))
		((string= atr "full")(setq EndTable (FullJoin (cdr FirstTable) (cdr SecondTable) (car FirstIndex) (car SecondIndex) (List-length (car FirstTable)) (List-length (car SecondTable)))))
		((string= atr "left")(setq EndTable (LeftJoin (cdr FirstTable) (cdr SecondTable) (car FirstIndex) (car SecondIndex) (List-length (car SecondTable)))))
		((string= atr "right")(setq EndTable(RightJoin (cdr FirstTable) (cdr SecondTable) (car FirstIndex) (car SecondIndex) (List-length (car FirstTable)))))
	)

	(setf EndTable (push (append (car FirstTable) (car SecondTable)) EndTable))

)

(defun InnerJoin(FirstTable SecondTable FirstIndex SecondIndex)
	(clearLst)
	(loop for x in FirstTable do(
		loop for y in SecondTable do(
			if (string= (nth FirstIndex x) (nth SecondIndex y))
				(push (append x y) Lst)
		)
	))
	(nreverse Lst)
)

(defun FullJoin (FirstTable SecondTable FirstIndex SecondIndex FirstMax SecondMax)
	(InnerJoin FirstTable SecondTable FirstIndex SecondIndex)
	(nreverse Lst)
	(loop for x in FirstTable do
		(FullJoin1 x SecondTable FirstIndex SecondIndex FirstMax SecondMax "back")
	)
	(loop for x in SecondTable do(
		FullJoin1 x FirstTable FirstIndex SecondIndex FirstMax SecondMax "front"
	))
	(nreverse Lst)
)

(defun FullJoin1 (FirstTable SecondTable FirstIndex SecondIndex FirstMax SecondMax pointer &optional (test 0))
	(if (= test 0)
		(if (not (null SecondTable))
				(if (string= (nth FirstIndex FirstTable) (nth SecondIndex (car SecondTable)))
					(FullJoin1 FirstTable (cdr SecondTable) FirstIndex SecondIndex FirstMax SecondMax pointer (+ test 1))
					(FullJoin1 FirstTable (cdr SecondTable) FirstIndex SecondIndex FirstMax SecondMax pointer))
				(JoinHelper FirstTable SecondMax pointer)
		)
	)
)

(defun JoinHelper(el Max pointer)
	(if (> Max 0)
		(if (string= pointer "front")
			(JoinHelper (push "null" el) (- Max 1) pointer)
			(JoinHelper (append el '("null")) (- Max 1) pointer))
		(push el Lst)
	)
)

(defun LeftJoin(FirstTable SecondTable FirstIndex SecondIndex Max)
	(InnerJoin FirstTable SecondTable FirstIndex SecondIndex)
	(nreverse Lst)
	(loop for x in FirstTable do
		(LeftJoin1 x SecondTable FirstIndex SecondIndex Max "back")
	)
	(nreverse Lst)
)

(defun LeftJoin1(FirstTable SecondTable FirstIndex SecondIndex Max pointer &optional (test 0))
	(if (= test 0)
		(if(not (null SecondTable))
				(if (string= (nth FirstIndex FirstTable) (nth SecondIndex (car SecondTable)))
				(LeftJoin1 FirstTable (cdr SecondTable) FirstIndex SecondIndex  Max pointer (+ test 1))
				(LeftJoin1 FirstTable (cdr SecondTable) FirstIndex SecondIndex  Max pointer))
				(JoinHelper FirstTable Max pointer)
		)		
	)
)

(defun RightJoin(FirstTable SecondTable FirstIndex SecondIndex Max)
	(InnerJoin FirstTable SecondTable FirstIndex SecondIndex)
	(nreverse Lst)
	(loop for x in SecondTable do(
			RightJoin1 x FirstTable FirstIndex SecondIndex Max "front"
		))
	(nreverse Lst)
)

(defun RightJoin1(FirstTable SecondTable FirstIndex SecondIndex Max pointer &optional (test 0))
	(if (= test 0)
		(if(not (null SecondTable))
				(if (string= (nth FirstIndex FirstTable) (nth SecondIndex (car SecondTable)))
				(RightJoin1 FirstTable (cdr SecondTable) FirstIndex SecondIndex  Max pointer (+ test 1))
				(RightJoin1 FirstTable (cdr SecondTable) FirstIndex SecondIndex  Max pointer))
				(JoinHelper FirstTable Max pointer)
		)		
	)
)


(defun BetterTable(table max &optional (EndTable '()))
	(if (not (null table))
			(if (= (list-length (car table)) max)
				(BetterTable (cdr table) max (push (car table) EndTable))
				(BetterTable (cdr table) max (push (append (car table) '("null")) EndTable))
			)
			(nreverse EndTable)
	)
)


(setq data (read-line))
(setq command (ReadCommand data))
(ExecuteProg command data)
